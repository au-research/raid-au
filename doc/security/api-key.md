
## API key 

Referred to in most documentation as "api-key", referred to in the 
app-client UI as an "API key".

The api-key is the entity that an OPERATOR or SP_ADMIN user creates (via the 
app-client UI) to allow integration via the API.

An api-key is created and maintained using the app-client UI.  


## API token

Referred to in most doco as "api-token", referred to in the app-client as just
"token".

The api-token is the actual JWT that is sent with every API request as a
bearer token in the `Authorization` header for each HTTP request.

Many api-tokens can be associated with a single api-key. 
When your api-token is approaching the expiry date, you don't have to create a 
new api-key, you can just extend the expiry date and any new api-token generated
after that will use the new expiry date.

The api-token is not stored in the RAiD service, once it is generated it is
thrown away.

An api-token for integration is generated manually in the app-client
(on the "API key" page). 

The actual api-token is generated by the 
`/v2/experimental/generate-api-token/v1` 
endpoint (this is what the "generate token" button uses). 

Note that we don't currently validate the role in the claim (from when 
the api-token was generated) against the current value on the api-key in 
the DB. That means an api-token created before the api-key is changed is
still valid, but functions using the role from the api-token, not from 
the api-key.

If you "demote" an api-key from `SP_ADMIN` to `SP_USER` and want to make sure 
that no existing api-tokens are allowed to invoke endpoints using the elevated
permission - you will have to disable the api-key (which will invalidate 
*all* api-tokens associated with that api-key), then create a new api-key 
with the reduced role and generate a new api-token.

Theoretically, we could create an api-token generation endpoint that 
creates ephemeral api-tokens for an API client to use, but we'd have to 
setup a machine-to-machine OAuth2 flow - contact us if you're keen on 
that.

## api-keys and api-tokens across environments

One benefit of the api-token approach is that we can use the same api-key 
(and same app-user records for human users too).

Note that the actual api-tokens don't work across environments.
If you decode an api-token, you will note that the environment that created the
api-token is embedded as the `issuer` claim.  An api-token issued in PROD 
env cannot be used in DEMO and vice-versa (the environments also use 
different signing keys for the actual JWT).

But; an api-token issued in DEMO will continue to work in DEMO even after 
a DB refresh from PROD. This  works as long as the api-key was present in PROD 
before the DB baseline was taken (and the api-key has not been disabled). 

The api-token verification works by looking up the api-key in the DB
via the `app_user.id` column (i.e. surrogate key), read from the `APP_USER_ID`.
That's why you need to create an api-key in the PROD environment if you want 
api-tokens to work long-term, across DB refreshes, in the DEMO environment.

### Future changes to api-token format

We ought to rename the `APP_USER_ID` to `API_KEY_ID` and the `EMAIL` claim
should be renamed to `IDENTITY`.

When this is done though, we will keep the authorization logic backward 
compatible so that all api-tokens issued with the previous claims will 
continue to work.

The old claim logic will be removed once we're sure there are no old api-tokens
being used in PROD environment.  Remember that the "expiry" period of the 
api-key may have been extended, so there could be api-tokens out there with 
longer expiry claims than you think.



# Database model

At the moment, both app-user and api-key are stored in the `app_user` table.
See [app-user.md](./app-user.md#database-model) for more info.

