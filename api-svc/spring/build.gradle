plugins{
  id 'java'
}

ext{
  idRaidV1Project = project(":api-svc:idl-raid-v1")
  
  idlGeneratedSrcDir = file('src/main/generated-idl')

  defaultSysProps = [
    /* prod machines will always be set to UTC, but developer machines are set 
    to whatever they want - so this forces it for gradle stuff. */
    'user.timezone': 'UTC',
    // platform specific, so force it
    'file.encoding': 'UTF-8',
    // for consistency, rather than any specific reason 
    "user.language":"", "user.country":"", "user.variant":"",
  ]
  
  // the config loading config :/
  homeDir = System.properties['user.home']
  configPath = System.getProperty("RAIDOV2_APISVC_CONFIG_PATH",
    "${homeDir}/.config/raido-v2/api-svc.gradle")
}

/* after ext{} block so that stuff is the default, and so the config
   can refer to those default values */
if( file(configPath).exists() ){
  println "loading config from: ${configPath}"
  /* never done config this way before, not entirely sure it's a good idea,
  probably a Bad Plan to a full turing-complete language for config */
  apply from: configPath
}

repositories{
  mavenCentral()
  
  // needed for resolving spring-6 milestone builds
  maven { url "https://repo.spring.io/libs-milestone" }
}

/* don't use groovy for prod code: dynamic typing, slow startup and poor 
   historical upgrade compatibility */
dependencies{
  implementation project(':api-svc:db:raido')
  
  // look in settings.gradle for version catalog specs 
  implementation libs.bundles.jetty11
  implementation libs.bundles.spring6
  implementation libs.jooq


  // use the standard jar instead of binding unnecessarily to Jetty
  // pkg: jakarta.servlet - used to be javax.servlet  
  compileOnly 'jakarta.platform:jakarta.jakartaee-web-api:9.1.0'

  /* use SLf4J API to log against - pkg: org.slf4j
     using 2.0.0 for Raido code because that's what jetty uses
     NOTE:STO: this might not be right since we're Jetty 11/Servlet 5 */
  implementation 'org.slf4j:slf4j-api:2.0.0-alpha7'
  // allow SLF4J to capture java.util logging 
  implementation 'org.slf4j:jul-to-slf4j:2.0.0-alpha7'

  // for working with JWTs - most popular library
  implementation 'com.auth0:java-jwt:4.0.0'

  // connection pool
  implementation "com.zaxxer:HikariCP:3.4.5"

  // for PostConstruct/PreDestroy - pkg: jakarta.annotation (used to be javax)
  implementation 'jakarta.annotation:jakarta.annotation-api:2.1.1'

  // logging DB statements
  implementation 'p6spy:p6spy:3.9.1'

  // postgres DB driver
  runtimeOnly libs.pgjdbc

  // support for JSON serialization for Spring endpoints
  runtimeOnly 'com.fasterxml.jackson.core:jackson-databind:2.13.3'
  // support for XML serialization for APIDS endpoints (probably others later)
  implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.13.3'

  // so that MappingJackson2XmlHttpMessageConverter can parse to LocalDateTime 
  implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.13.3"
  
  // use logback as the backing log implementation for slf4j
  runtimeOnly libs.bundles.logback.runtime

  testImplementation libs.bundles.spring6.test

  testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
  testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'

  testImplementation libs.assertj

  // because MockRestServiceServer couldn't find class org.hamcrest.Matcher
  testImplementation 'org.hamcrest:hamcrest:2.2'
 
}

compileJava {
  options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
}

testing{
  suites{
    intTest(JvmTestSuite){
      testType = TestSuiteType.FUNCTIONAL_TEST
      dependencies{
        implementation project
        implementation project(':api-svc:db:raido')

        // for booting a custom test server
        implementation libs.bundles.jetty11

        // for having our own spring context in intTest
        implementation libs.bundles.spring6
        implementation libs.bundles.spring6.test
        
        implementation libs.assertj

        implementation libs.jooq

        // for PostConstruct/PreDestroy - pkg: jakarta.annotation (used to be javax)
        implementation 'jakarta.annotation:jakarta.annotation-api:2.1.1'
        
      }
    }
  }
}
tasks.intTest.description = "don't run this, it's just a Gradle default"

sourceSets{
  main.java{
    srcDirs += [idlGeneratedSrcDir]
  }
  test.resources{
    /* This is so each test's resources are right next to the source.
    It also makes the src/test/resources directory redundant - might as well
    have properties, xml, etc. files under here. 
    There's no point in separating resource from code in the context of testing 
    (and little point for prod code in the general case, IMO). */
    srcDirs "src/test/java"
  }
  intTest.resources{
    srcDirs "src/intTest/java"
  }
}

// compile intTest classes - but don't run by default (needs DDB migration)
tasks.build.dependsOn intTestClasses

test{
  useJUnitPlatform()
  systemProperties defaultSysProps
}

intTest{
  useJUnitPlatform()
  systemProperties defaultSysProps
}

task cleanIdlRaidV1Src(type: Delete){
  group = "idl"
  delete idlGeneratedSrcDir
}

task generateIdlRaidV1Src(type:Copy){
  group = "idl"
  description = "clean idl then use :api-svc:idl-raid-v1:openApiGenerate"
  dependsOn cleanIdlRaidV1Src, idRaidV1Project.tasks.openApiGenerate
  from( idRaidV1Project.generateDir){
    /* excluding these for the moment because dunno how to make them use 
    the identity param (i.e. want openapi to generate a `identity` param of
    type PostAuthenicationJsonWebToken, so we can't implement the generated
    Api.java interface classes.  This is subjective though, some pople don't 
    want the identity param anyway (prefer to bind in to spring or something 
    I guess).  */
    exclude "raido/idl/raidv1/api/**"
  }
  destinationDir idlGeneratedSrcDir
}
/* Its ok to included generation as part of the build process, IDL is different 
from JOOQ stuff because we don't need a DB to generate the code. */
tasks.compileJava.dependsOn generateIdlRaidV1Src