plugins{
  id 'java'
}

ext{
  defaultSysProps = [
    /* prod machines will always be set to UTC, but developer machines are set 
    to whatever they want - so this forces it for gradle stuff. */
    'user.timezone': 'UTC',
    // platform specific, so force it
    'file.encoding': 'UTF-8',
    // for consistency, rather than any specific reason 
    "user.language":"", "user.country":"", "user.variant":"",
  ]
  
  // the config loading config :/
  homeDir = System.properties['user.home']
  configPath = System.getProperty("RAIDO_APISVC_CONFIG_PATH",
    "${homeDir}/.config/raido/api-svc.gradle")
}

/* after ext{} block so that stuff is the default, and so the config
   can refer to those default values */
if( file(configPath).exists() ){
  println "loading config from: ${configPath}"
  /* never done config this way before, not entirely sure it's a good idea,
  probably a Bad Plan to use a full turing-complete language for config */
  apply from: configPath
}

repositories{
  mavenCentral()
}

version = rootProject.version

/* don't use groovy for prod code: dynamic typing, slow startup and poor 
   historical upgrade compatibility */
dependencies{
  implementation project(':api-svc:db:raido')
  implementation project(':api-svc:idl-raid-v1')
  implementation project(':api-svc:idl-raid-v2')
  
  // look in settings.gradle for version catalog specs 
  implementation libs.bundles.jetty11
  implementation libs.bundles.spring6
  implementation libs.jooq

  /* use SLf4J API to log against - pkg: org.slf4j
     using 2.0.0 for Raido code because that's what jetty uses
     NOTE:STO: this might not be right since we're Jetty 11/Servlet 5 */
  implementation 'org.slf4j:slf4j-api:2.0.5'
  // allow SLF4J to capture java.util logging 
  implementation 'org.slf4j:jul-to-slf4j:2.0.5'

  // connection pool - upgraded from 3.4.5, rollback if issues with 5.0.0
  implementation "com.zaxxer:HikariCP:5.0.0"

  // for PostConstruct/PreDestroy - pkg: jakarta.annotation (used to be javax)
  implementation 'jakarta.annotation:jakarta.annotation-api:2.1.1'

  // logging DB statements
  implementation 'p6spy:p6spy:3.9.1'

  // postgres DB driver
  runtimeOnly libs.pgjdbc

  // support for JSON serialization for Spring endpoints
  runtimeOnly 'com.fasterxml.jackson.core:jackson-databind:2.13.4.2'
  // support for XML serialization for APIDS endpoints (probably others later)
  implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.14.1'

  // so that MappingJackson2XmlHttpMessageConverter can parse to LocalDateTime 
  implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.14.1"

  /* used for:
   - generating/verifying HS256 JWTs for RAID v1 tokens 
   - verifying OIDC (google, aaf) RS256 JWTs 
   - generating/verifying HS256 JWTs for raido authz token  
   */
  implementation 'com.auth0:java-jwt:4.2.1'
  implementation 'com.auth0:jwks-rsa:0.21.2'

  // so we can customise to disable followRedirects for tests 
  implementation "com.squareup.okhttp3:okhttp:4.10.0"
  
  // use logback as the backing log implementation for slf4j
  runtimeOnly libs.bundles.logback.runtime

  testImplementation libs.bundles.spring6.test

//  testImplementation 'org.mockito:mockito-core:4.11.0'
  testImplementation 'org.mockito:mockito-inline:4.11.0'
  testImplementation 'org.mockito:mockito-junit-jupiter:4.11.0'
  testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.1'
  testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.1'

  testImplementation libs.assertj

  // because MockRestServiceServer couldn't find class org.hamcrest.Matcher
  testImplementation 'org.hamcrest:hamcrest:2.2'

  // beacuse Spring MockMvc couldn't find jakarta.servlet.ServletConnection
  testImplementation 'jakarta.servlet:jakarta.servlet-api:6.0.0'

  // needed for jsonpath testing in Spring MVC tests
  testImplementation 'com.jayway.jsonpath:json-path:2.7.0'

}

compileJava {
  options.compilerArgs <<
    // avoid warnings about spring classes using deprecated '-debug' 
    "-parameters" <<
    // annoy people into not doing unchecked shenanigans ðŸ˜’
    "-Xlint:unchecked" <<
    // annoy people into fixing their deprecation warnings 
    "-Xlint:deprecation"
}

testing{
  suites{
    intTest(JvmTestSuite){
      testType = TestSuiteType.INTEGRATION_TEST
      dependencies{
        implementation project()
        implementation project(':api-svc:db:raido')
        implementation project(':api-svc:idl-raid-v1')
        implementation project(':api-svc:idl-raid-v2')

        // for booting a custom test server
        implementation.bundle libs.bundles.jetty11

        // for having our own spring context in intTest
        implementation.bundle libs.bundles.spring6
        implementation.bundle libs.bundles.spring6.test

        implementation.bundle libs.bundles.feign

        implementation libs.assertj

        implementation libs.jooq

        // for PostConstruct/PreDestroy - pkg: jakarta.annotation (used to be javax)
        implementation 'jakarta.annotation:jakarta.annotation-api:2.1.1'
        
        implementation( 'org.springframework.cloud:spring-cloud-starter-openfeign:3.1.2'){
          /* Not a huge deal to pull in spring-boot, since it's only the 
          integration tests - but still I don't want to deal with it.
          - avoids having to ignore all the confusing and unused  
          implementations of Spring interfaces that it includes.
          - avoids any "it was already included" arguments. */
          exclude group: 'org.springframework.boot'
        }
        implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.13.3"

        implementation 'com.auth0:java-jwt:4.0.0'

      }
    }
  }
}
tasks.intTest.description = "don't run this, it's just a Gradle default"

sourceSets{
  test.resources{
    /* This is so each test's resources are right next to the source.
    It also makes the src/test/resources directory redundant - might as well
    have properties, xml, etc. files under here. 
    There's no point in separating resource from code in the context of testing 
    (and little point for prod code in the general case, IMO). */
    srcDirs "src/test/java"
  }
  intTest.resources{
    srcDirs "src/intTest/java"
  }
}

// compile intTest classes - but don't run by default (needs DDB migration)
tasks.build.dependsOn intTestClasses

test{
  useJUnitPlatform()
  systemProperties defaultSysProps
}

intTest{
  useJUnitPlatform()
  systemProperties defaultSysProps
  testLogging.showStandardStreams = true  
}

task buildInfo(type: WriteProperties){
  description = "Write build-info.properties file"
  outputFile = file("${sourceSets.main.output.resourcesDir}/META-INF/build-info.properties")
  encoding = "UTF-8"
  comment = "This file built by Gradle task buildInfo"

  property("build.version", project.version)
  property("build.commitId", rootProject.gitCommitHash)
  // we don't use it for stuff, it's for people, so format it nice
  property("build.buildDate", new Date().toString())
}
processResources.dependsOn buildInfo

task uberJar(type: Jar) {
  group "distribution"
  // using `=`, IDEA error warn about archiveClassifier exceeds access rights  
  archiveClassifier.set('uber')

  // different name from standard jar and don't want version in the name
  // Name of the jar is hardcoded in the Dockerfile 
  archiveFileName = "raido-api-svc.jar"

  //noinspection GroovyAssignabilityCheck
  manifest{

    //noinspection GroovyAssignabilityCheck
    duplicatesStrategy "EXCLUDE"
    attributes (
      'Main-Class': 'raido.apisvc.Api',
      "Implementation-Title": "Raido",
      // archiveVersion comes from project version, so it'll use our value
      "Implementation-Version": archiveVersion,
    )
  }

  dependsOn configurations.runtimeClasspath
  from sourceSets.main.output
  from {
    configurations.runtimeClasspath.findAll {
      it.name.endsWith('jar') }.collect { zipTree(it)
    }
  }

  doFirst{
    println "generating uberJar to ${archiveFile.get()} from version ${archiveVersion}"
  }
}
tasks.build.dependsOn uberJar
