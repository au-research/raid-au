plugins{
  id 'java'
  alias(libs.plugins.flyway)
  alias(libs.plugins.jooq)
}

evaluationDependsOn(':api-svc:v1-ddb-migration')

ext{
  idRaidV1Project = project(":api-svc:idl-raid-v1")
  
  apiSvcPgUrl = "jdbc:postgresql://localhost:7432/raido"
  apiSvcPgUser = 'postgres'
  apiSvcPgPassword = ""
  apiSvcPgSchema = "api_svc"

  jooqGeneratedSrcDir = 'src/main/generated-jooq'
  jooqGeneratedPkg = 'raido.db.jooq'

  idlGeneratedSrcDir = file('src/main/generated-idl')

  defaultSysProps = [
    /* prod machines will always be set to UTC, but developer machines are set 
    to whatever they want - so this forces it for gradle stuff. */
    'user.timezone': 'UTC',
    // platform specific, so force it
    'file.encoding': 'UTF-8',
    // for consistency, rather than any specific reason 
    "user.language":"", "user.country":"", "user.variant":"",
  ]
  
  // the config loading config :/
  homeDir = System.properties['user.home']
  configPath = System.getProperty("RAIDOV2_APISVC_CONFIG_PATH",
    "${homeDir}/.config/raido-v2/api-svc.gradle")
}

/* after ext{} block so that stuff is the default, and so the config
   can refer to those default values */
if( file(configPath).exists() ){
  println "loading config from: ${configPath}"
  /* never done config this way before, not entirely sure it's a good idea,
  probably a Bad Plan to a full turing-complete language for config */
  apply from: configPath
}
// must be done after config from file to pick up credentials and overrides
ext.defaultSysProps += project.extensions.extraProperties.properties.
  findAll{ it.key.startsWith("apiSvcPg") }

repositories{
  mavenCentral()
  
  // needed for resolving spring-6 milestone builds
  maven { url "https://repo.spring.io/libs-milestone" }
}

/* don't use groovy for prod code: dynamic typing, slow startup and poor 
   historical upgrade compatibility */
dependencies{
  // look in settings.gradle for version catalog specs 
  implementation libs.bundles.jetty11
  implementation libs.bundles.spring6  
  implementation libs.jooq

  // use the standard jar instead of binding unnecessarily to Jetty
  // pkg: jakarta.servlet - used to be javax.servlet  
  compileOnly 'jakarta.platform:jakarta.jakartaee-web-api:9.1.0'

  /* use SLf4J API to log against - pkg: org.slf4j
     using 2.0.0 for Raido code because that's what jetty uses
     NOTE:STO: this might not be right since we're Jetty 11/Servlet 5 */
  implementation 'org.slf4j:slf4j-api:2.0.0-alpha7'
  // allow SLF4J to capture java.util logging 
  implementation 'org.slf4j:jul-to-slf4j:2.0.0-alpha7'

  // for working with JWTs - most popular library
  implementation 'com.auth0:java-jwt:4.0.0'

  // connection pool
  implementation "com.zaxxer:HikariCP:3.4.5"

  // for PostConstruct/PreDestroy - pkg: jakarta.annotation (used to be javax)
  implementation 'jakarta.annotation:jakarta.annotation-api:2.1.1'

  // logging DB statements
  implementation 'p6spy:p6spy:3.9.1'

  // postgres DB driver
  runtimeOnly libs.pgjdbc
  jooqGenerator libs.pgjdbc

  // support for JSON serialization for Spring endpoints
  runtimeOnly 'com.fasterxml.jackson.core:jackson-databind:2.13.3'
  // support for XML serialization for APIDS endpoints (probably others later)
  implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.13.3'

  // so that MappingJackson2XmlHttpMessageConverter can parse to LocalDateTime 
  implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.13.3"
  
  // use logback as the backing log implementation for slf4j
  runtimeOnly libs.bundles.logback.runtime

  testImplementation libs.bundles.spring6.test

  testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
  testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'

  testImplementation libs.assertj

  // because MockRestServiceServer couldn't find class org.hamcrest.Matcher
  testImplementation 'org.hamcrest:hamcrest:2.2'
 
}

compileJava {
  options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
}

testing{
  suites{
    funcTest(JvmTestSuite){
      testType = TestSuiteType.FUNCTIONAL_TEST
      dependencies{
        implementation project

        // for booting a custom test server
        implementation libs.bundles.jetty11

        // for having our own spring context in functTest
        implementation libs.bundles.spring6
        implementation libs.bundles.spring6.test
        
        implementation libs.assertj

      }
    }
  }
}
tasks.funcTest.description = "don't run this, it's just a Gradle default"

sourceSets{
  main.java{
    srcDirs += [jooqGeneratedSrcDir, idlGeneratedSrcDir]
  }
  test.resources{
    /* This is so each test's resources are right next to the source.
    It also makes the src/test/resources directory redundant - might as well
    have properties, xml, etc. files under here. 
    There's no point in separating resource from code in the context of testing 
    (and little point for prod code in the general case, IMO). */
    srcDirs "src/test/java"
  }
  funcTest.resources{
    srcDirs "src/funcTest/java"
  }
}

// compile funcTest classes - but don't run by default (needs DDB migration)
tasks.build.dependsOn funcTestClasses

test{
  useJUnitPlatform()
  systemProperties defaultSysProps
}

funcTest{
  useJUnitPlatform()
  systemProperties defaultSysProps
}


flyway{
  url = apiSvcPgUrl
  user = apiSvcPgUser
  password = apiSvcPgPassword
  schemas = [apiSvcPgSchema]
}

task cleanJooqGeneratedSrc(type: Delete){
  group = "jooq"
  delete jooqGeneratedSrcDir
}

jooq{
  version = libs.versions.jooq.get()
  configurations{
    main{  // name of the jOOQ configuration
      generateSchemaSourceOnCompilation = false

      generationTool{
        jdbc{
          driver = 'org.postgresql.Driver'
          url = apiSvcPgUrl
          user = apiSvcPgUser
          password = apiSvcPgPassword
        }
        generator{
          name = 'org.jooq.codegen.DefaultGenerator'
          database{
            name = 'org.jooq.meta.postgres.PostgresDatabase'
            schemata{
              schema{
                inputSchema = apiSvcPgSchema
              }
              schema{
                // weird error about "project"
//                inputSchema = project(":api-svc:v1-ddb-migration").ext.raidV1PgSchema
                inputSchema = 'raid_v1_import'
              }
            }
          }
          
          generate{
            deprecated = false
            records = true
            immutablePojos = false
            fluentSetters = true
            globalTableReferences = false
          }
          target{
            // gets blown away by the clean task each it's run
            directory = jooqGeneratedSrcDir
            packageName = jooqGeneratedPkg
          }
        }
      }
    }
  }
}
tasks.generateJooq.dependsOn cleanJooqGeneratedSrc

task cleanIdlRaidV1Src(type: Delete){
  group = "idl"
  delete idlGeneratedSrcDir
}

task generateIdlRaidV1Src(type:Copy){
  group = "idl"
  description = "clean idl then use :api-svc:idl-raid-v1:openApiGenerate"
  dependsOn cleanIdlRaidV1Src, idRaidV1Project.tasks.openApiGenerate
  from( idRaidV1Project.generateDir){
    /* excluding these for the moment because dunno how to make them use 
    the identity param (i.e. want openapi to generate a `identity` param of
    type PostAuthenicationJsonWebToken, so we can't implement the generated
    Api.java interface classes.  This is subjective though, some pople don't 
    want the identity param anyway (prefer to bind in to spring or something 
    I guess).  */
    exclude "raido/idl/raidv1/api/**"
  }
  destinationDir idlGeneratedSrcDir
}
/* Its ok to included generation as part of the build process, IDL is different 
from JOOQ stuff because we don't need a DB to generate the code. */
tasks.compileJava.dependsOn generateIdlRaidV1Src