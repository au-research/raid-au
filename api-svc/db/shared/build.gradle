ext{
  apiSvcPgUrl = "jdbc:postgresql://localhost:7432/raido"
  apiSvcPgSchema = "api_svc"
  
  /*  This is a different user than what the api-svc uses, this user must 
  be able to create schemas, tables, etc. 
  In an AWS env, this is the RDS master user; locally, probably just 'postgres' 
  */
  apiSvcPgUser = 'postgres'
  apiSvcPgPassword = ""
  
  apiSvcMigrationHost = ""
  apiSvcMigrationKey = ""
  
  /* this is the password used by the api-svc, we need it at the gradle level
  so the flyway scripts can set the password for the api_user role. */
  apiSvcRolePassword = null
  
  // non-prod, usually want to set in ~/.config/raido/api-svc-db.gradle:
  // apiSvcExtraLocations=["classpath:db/env/api_user","classpath:db/env/demo"]
  apiSvcExtraLocations = [""]

  /* force the user to override this explicitly in their environment. 
  The idea is to avoid accidentally running this in prod. */
  flywayCleanDisabled = true
  
  jooqGeneratedSrcDir = 'src/main/generated-jooq'
  jooqGeneratedPkg = 'raido.db.jooq'

  // the config loading config :/
  homeDir = System.properties['user.home']
  configPath = System.getProperty("RAIDOV2_APISVC_DB_CONFIG_PATH",
    "${homeDir}/.config/raido/api-svc-db.gradle")
}

/* after ext{} block so that stuff is the default, and so the config
   can refer to those default values */
if( file(configPath).exists() ){
  println "loading config from: ${configPath}"
  /* never done config this way before, not entirely sure it's a good idea,
  probably a Bad Plan to a full turing-complete language for config */
  apply from: configPath
}
else {
  println "no file found at: ${configPath}"
}

